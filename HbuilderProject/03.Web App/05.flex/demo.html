<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>弹性盒子布局</title>
		<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
		<style>
			*{
				padding: 0;margin:0;
			}
			footer{
				width:100%;
				height: 3rem;
				display: flex;
			}
			footer>div{
				width:25%;
				height:3rem;
				background-color:#acacac;
				border:1px solid #fafafa;
				text-align: center;
				line-height: 3rem;
				
			}
			.div1{
				background-color: red;
				animation: moves 5s infinite linear;
			}
			.div2{
				flex-shrink:1;
			}
			@keyframes moves{
				20%{flex-grow:3;}
				40%{flex-grow:5;}
				60%{flex-grow:7;}
				100%{flex-grow:8;}
			}
			
			
			
		</style>
		<script>
		   //当一个元素被声明成弹性盒子的时候，父元素变成了弹性盒模型
		   //子元素就是这个弹性盒模型的子项 item
		   //弹性盒什么样的盒子模型
		   //弹性盒子中包括两条线-----主轴线,纵轴线(可以让子项作为对其和定位的参考位置)
		   //主轴线      从最左边正中央,走向最右边
		   //纵轴线是  从最上边的正中央，往下走
		   
		   //属性 1.flex-direction:在父元素中设置子项的排列方式
		   // row-reverse 一些反排序的案例 横向 row,row-reverse
		   // column      纵向排布 ,column-reverse 纵向反向排布
		   //属性2.flex-direction 和响应式结合实现从左右布局到流式布局变换
		   
		   //flex-warp 换行属性  nowarp,warp,warp-reverse(反向换行)
		   
		   //属性3.justify-content 设置子项在父级主轴方向的对齐方式
		   //center---表示居中对齐
		   //flex-start 左对齐
		   //flex-end右对齐
		   //space-between  //两端对齐 中间距离一直
		   //space-around   //两端间隔一致
		   
		   //属性4: align-items:在父元素中设定设置子项在纵轴方向的排列
		   
		   
		   /****@media 1000 -1440{
		    *   footer{
		    * 	  display:flex;
		    *     height:4rem;
		    *   }
		    *   footer>div{
		    * 	 width:100%;
		    *    height:100%;
		    * }
		    * 
		    }**/
		    
		    /****@media 375 -640{
		    *   footer{
		    * 	  display:flex;
		    *     height:4rem;
		    *     flex-direction:column;
		    *   }
		    *   footer>div{
		    * 	 width:100%;
		    *    height:100%;
		    * }
		    * 
		    }**/
		   
		   
		   
		   
		   
		</script>
	</head>
	<body>
		<footer>
			<div class="div1">1</div>
			<div class="div2">2</div>
		</footer>
	</body>
</html>
