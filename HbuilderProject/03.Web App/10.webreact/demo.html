<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>整理</title>
		<script>
			//1.jsx,组件创建,组件去构建页面(组件多次渲染),组件嵌套
			
			//2.props，state进行数据传递,(数据传递的载体)
			//react 组件的生命周期学习(
				//1.载入--声明组件并渲染的时候
				//钩子函数----1.监听组件从声明开始到结束 经过步骤
				//---------2.这些钩子函数 可以让我们 手动控制组件
				
				  //getDefaultProps,getInitialState,componentWillMount,render,componentDidMount
				//2.运行中----组件内容更新的时候
				  //componentWillReceiveProps,shouldComponentUpdate(返回值 true组件更新,false停止更新)
				  //compontWillUpdate,componentDidUpdate,
				//3.被卸载的时候
				  //组件已经卸载,没有定义生命周期函数 
			//)
		</script>
		<script type="text/javascript" src="lib/react.min.js" ></script>
		<script type="text/javascript" src="lib/react-dom.min.js" ></script>
		<script type="text/javascript" src="lib/browser.min.js" ></script>
	</head>
	<body>
		
	</body>
	<script type="text/babel">
		var TestComponent=React.createClass({
			//1.现在可以在外部定义一个jsx作为模板  var jsx=(<div></div>);
			//2.ajax拿到数据 循环 叠加模板(模板push到了一个数组里面)
			//3.通过表达式 将这个叠加后得到数据 嵌套在组件中
			render:function(){
				//商品数据列表
				var source=["this is cloth","this is shoes","this is wuqiang","this is dong"];
				var comp=[];
				
				for(var i=0;i<source.length;i++){
					comp.push(<Item name={source[i]}/>);
				}
				return (
					<div>This is shop list
					  {comp}
					</div>
				)
			}
		});
		//声明渲染模板-----子组件，功能负责数据解析
		var Item=React.createClass({
			render:function(){
				console.log(this.props.name);
				return(
					<div>
					  <span>this is:{this.props.name}</span>
					</div>
				);
			}
		});
		
		ReactDOM.render(<TestComponent/>,document.body);
		//1.目前模板是我们自己任意定义的,样式不好控制 
		//2.模板里面分层更加深入,模板内容很长,写在render里面代码可读性很低
		//3.数据获取和解析是不是都发生在一个组件里面
		
		//解决问题？
		//1.在做react组件设计的时候，我们就可以把页面中数据显示的地方，分割父子组件嵌套的结构
		//比如说 商品数据显示的列表    最外层容器看成是一个父组件,里面数据显示的渲染模板,可以看成是一个子组件
		
		//2.就是在第一步基础上，可以让父组件只负责获取数据，让子组件更新
		
		//3.总结:用react实现数据绑定核心思想，实现组件的嵌套(父组件和子组件之间相互独立,父组件只负责获取数据，子组件只负责更新)
		
		
		
		
	</script>
</html>
